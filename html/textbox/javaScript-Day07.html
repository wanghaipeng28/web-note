<html>
	<head>
		<title>Day07</title>
		<meta http-equiv="content-type" content="text/html;charset=utf-8" />
	</head>
	<body style="margin:0px;">
		<pre style="word-wrap: break-word; white-space: pre-wrap;background-color:#B5D7B5;font-size:20pt;padding-top:50px;">
			回顾: 
			1. *Date

			正课:
			1. 错误处理
			2. ***Function
			   ***重载
			   ***匿名函数
			   ***作用域和作用域链
			   *****闭包

			1. 错误处理: 
			   错误: 程序运行中发生的异常问题
					 一旦发生错误，引擎停止执行后续程序
			   错误(异常)处理: 在程序发生错误时，依然保证程序不强行退出的机制。
			   如何处理: 
				try{
				   可能出错的正常代码;
				}catch(err){
				   错误处理的代码;
				}finally{
				   无论是否出错，始终执行的代码
				}

			   err: 在错误发生时，获得错误对象
				  错误对象: 封装错误信息的对象，在发生错误时自动创建

			   性能: 放在try中的代码，执行效率会降低
				 建议: 1. 在try中尽量少的，仅包含可能出错的代码
					   2. 绝大多数的错误，都可通过if提前预防——经验

			   特殊用途：判断浏览器兼容性问题: 
			   
			   异常处理中的return:
				1. 如果finally中没有return：
				   finally中的代码一定会在返回前被执行
					  finally中的代码不会影响返回值的结果
				2. 如果finally中有return
					 finally中的return会覆盖之前的return

			   主动抛出异常：
				 throw new Error("错误信息");
				何时使用: 函数的定义者，向函数调用者提示错误之用

			2. ***Function: 封装一个函数定义，提供对函数操作的API 的对象
			   创建: 3种: 
				 1. 声明: function 函数名(参数列表){函数体; return 返回值}
				 *********只有声明方式创建的函数才能被声明提前*********
				 2. 直接量: 
				var 函数名=function(参数列表){函数体; return 返回值}
				 3. 用new关键字:
					var 函数名=new Function("参数1","参数2",...,"函数体")
			   
			   重载(overload): 
				 什么是: 相同函数名，不同参数列表的多个函数。在调用时根据传入参数的不同，自动挑选对应的函数执行。
				 为什么: 现实中，不同操作步骤的相关任务，通常都起相同的任务名。为了减轻使用者的负担。
				 何时使用: 多个相似的任务，具有相同的任务名，只是参数和步骤不一样，则都要定义相同的函数名。
				 问题: js中不支持重载的语法。因为js不允许多个同名函数存在
				 解决: arguments
				   什么是: arguments是专门接受调用时所有传入的参数值的类数组对象。
				什么是类数组对象: 像数组的对象
					vs 数组: 相同:用下标访问每个元素
									  length属性记录元素个数
							 不同: 不能使用数组的任何API
				  arguments在调用函数时，在函数内部自动创建，并保存参数值




			正课:
			1. ***Function 
			  ***匿名函数
			  ***作用域和作用域链
			  *****闭包

			1. ***Function
			   ***匿名函数: 定义时，没有给定函数名的函数
			   为什么: 为了一次性使用，节省内存空间
			   何时使用: 只要一个函数，只执行一次，都要用匿名函数
			   如何使用: 
				  1. 回调: 将函数作为对象交给别的函数去调用
					   函数的调用时机，次数，以及参数与函数定义者无关
				  2. 自调: 定义完函数，立刻调用
					 (function(...){...})();
			   作用域和作用域链: 
				 作用域: 变量的可用范围
				   1. 全局作用域: 全局变量，随处可用，可反复使用
				   2. 函数作用域: 局部变量，仅函数内可用，函数调用后释放
				 作用域链: 从当前函数的AO到全局对象window形成的链式结构

			   *****闭包: 保护并重用局部变量的机制
				为什么: 全局变量: 优: 随处可用，可重用，缺: 易被污染
						局部变量: 优: 仅在函数内用，安全，缺: 不可重用
				何时使用: 希望重用一个变量，又不希望被污染时-保护局部变量
				如何定义: 3步: 
				  1. 定义受保护的局部变量
				  2. 定义内层函数专门操作受保护的变量
				  3. 定义外层函数将受保护的变量和操作变量的函数封装起来，外层函数将内层函数返回到外部
				
				鄙视时: 
				判断闭包: 1. 局部变量  2. 内层函数  3. 外层函数
				判断输出: 
				   1. 找到受保护的局部变量，判断外层函数调用后，它的值
				   2. 同一次外层函数调用返回的多个内层对象，操作的是同一个受保护的变量。

 
		</pre>
	</body>
</html>
